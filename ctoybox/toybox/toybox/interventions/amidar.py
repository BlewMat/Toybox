from toybox.interventions.base import *

import json
import random
from collections import namedtuple
"""An API for interventions on Amidar."""

# Someday all of these objects will be auto-generated by the Rust. 
# For now, manually specify them.

class Amidar(Game):

  expected_keys = Game.expected_keys + ['enemies', 'player', 'jumps', 'jump_timer', 'chase_timer', 'board']
  
  def __init__(self, intervention, 
    score=None, player=None, lives=None, rand=None, level=None,
    enemies=None, jumps=None, jump_timer=None, chase_timer=None, board=None):
    super().__init__(intervention, score, lives, rand, level)
    self.enemies = EnemyCollection.decode(intervention, enemies, EnemyCollection)
    self.jumps = jumps
    self.jump_timer = jump_timer
    self.chase_timer = chase_timer
    self.board = Board.decode(intervention, board, Board)
    self.player = Player.decode(intervention, player, Player)
    # convenience fields. These cannot be manually set and should only be treated as a softlink
    self.tiles = self.board.tiles

  def __setattr__(self, name, value):
    calling_fn = inspect.stack()[1].function
    if calling_fn != '__init__':
      # Various special cases here
      if name == 'tiles':
        raise AttributeError('tiles is a convenience field on Amidar. To set, access via Board object.')
      elif name == 'enemies':
        coll = EnemyCollection(self.intervention, value, directset=True)
        super().__setattr__(name, coll)
        self.intervention.dirty_state = True
        return 
    super().__setattr__(name, value)


class EnemyCollection(BaseMixin):

    expected_keys = []

    def __init__(self, intervention, enemies, directset=False):
      self.intervention = intervention
      self.enemies = enemies if directset else [Enemy.decode(intervention, e, Enemy) for e in enemies]
        
    def __iter__(self):
      return self.enemies.__iter__()

    def __getitem__(self, key):
      return self.enemies.__getitem__(key)

    def __len__(self):
      return self.enemies.__len__()

    def append(self, obj):
      assert isinstance(obj, Enemy), '%s must be of type Enemy' % obj
      self.enemies.append(obj)

    def decode(intervention, enemies, clz):
      return EnemyCollection(intervention, enemies)

    def encode(self):
      return [e.encode() for e in self.enemies]


class Enemy(BaseMixin):

    EnemyLookupAI     = 'EnemyLookupAI'
    EnemyPerimeterAI  = 'EnemyPerimeterAI' 
    EnemyAmidarMvmt   = 'EnemyAmidarMvmt' 
    EnemyTargetPlayer = 'EnemyTargetPlayer'
    EnemyRandomMvmt   = 'EnemyRandomMvmt'

    mvmt_protocols = [
        EnemyLookupAI, 
        EnemyPerimeterAI, 
        EnemyAmidarMvmt, 
        EnemyTargetPlayer, 
        EnemyRandomMvmt]

    expected_keys = ['history', 'step', 'position', 'caught', 'speed', 'ai']

    def __init__(self, intervention, history, step, position, caught, speed, ai):
      self.intervention = intervention
      self.history = history
      self.step = step
      self.position = position           if isinstance(position, WorldPoint) \
          else position.to_world_point() if isinstance(position, TilePoint) \
          else position.to_world_point() if isinstance(position, Tile) \
          else WorldPoint.decode(self.intervention, position, WorldPoint)
      self.caught = caught
      self.speed = speed
      assert len(ai.keys()) == 1  
      self.ai_name = list(ai.keys())[0]
      self.ai_kwds = ai[self.ai_name]
      assert self.ai_name in Enemy.mvmt_protocols

    def __setattr__(self, name, value):
      calling_fn = inspect.stack()[1].function
      if name.startswith('ai') and not (calling_fn == 'set_protocol' or calling_fn == '__init__'):
          raise AttributeError('Cannot manually set ai, ai_kwds, or ai_name. Use set_protocol instead.')
      super().__setattr__(name, value)
        
    def encode(self):
      js = super().encode()
      obj = {}
      for name, value in self.ai_kwds.items():
          obj[name] = value.encode() if isinstance(value, BaseMixin) else value
      js['ai'] = {self.ai_name : obj}
      return js

    def get_ai_arg(self, argname):
      """Returns the value of the input keyword. 
         
         All enemy movement protocols have the form:

         { <ai_name> : <keywords> }

         <ai_name> is one of the values listed in Enemy.mvmt_protocols.

         <keywords> is a map of enum elements needed for the rust. See the documentation for set_protocol for more information.
      """
      return self.ai_kwds[argname]

    def get_ai_kwds(self):
      return self.ai_kwds.keys()

    def set_protocol(self, protocol, **kwargs):
      """Sets the enemy movement protocol. Each instance in the rust has a different set of parameters:
  
      EnemyLookupAI
        next: u32
        default_route_index: u32
          
      EnemyPerimeterAI 
        start: TilePoint
  
      EnemyAmidarMvmt 
        vert: Direction
        horiz: Direction
        start_vert: Direction
        start_horiz: Direction
        start: TilePoint 
  
      EnemyRandomMvmt
        start: TilePoint
        start_dir: Direction
        dir: Direction
  
      EnemyTargetPlayer 
        start: TilePoint
        start_dir: Direction
        vision_distance: i32
        dir: Direction
        player_seen: Option<TilePoint>"""
      assert protocol in Enemy.mvmt_protocols
      def assert_keys(k, t): 
        assert k in kwargs, 'Missing argument %s for protocol %s' % (k, protocol)
      if protocol == Enemy.EnemyLookupAI:
        assert_keys('next', int)
        assert_keys('default_route_index', int)
      elif protocol == Enemy.EnemyPerimeterAI:
        assert_keys('start', TilePoint)
      elif protocol == Enemy.EnemyAmidarMvmt:
        assert_keys('vert', Direction)
        assert_keys('horiz', Direction)
        assert_keys('start_vert', Direction)
        assert_keys('start_horiz', Direction)
        assert_keys('start', TilePoint)
      elif protocol == Enemy.EnemyTargetPlayer:
        assert_keys('start', TilePoint)
        assert_keys('start_dir', Direction)
        assert_keys('vision_distance', int)
        assert_keys('dir', Direction)
        try: 
          assert_keys('player_seen', None)
        except:
          assert_keys('player_seen', TilePoint)
      elif protocol == Enemy.EnemyRandomMvmt:
        assert_keys('start', TilePoint)
        assert_keys('start_dir', Direction)
        assert_keys('dir', Direction)
      else: 
        raise ValueError('Unknown enemy movement protocol: %s' % protocol)
      # we have to do this manually because ai_name and ai_kwds are not 
      # elements of the expected_keys list,  so they are not caught by the 
      # overridden __setattr__ in the superclass
      self.intervention.dirty_state = True
      self.ai_name = protocol
      self.ai_kwds = kwargs
  

class Player(BaseMixin):

    expected_keys = ['history', 'step', 'position', 'caught', 'speed', 'ai']

    def __init__(self, intervention, history, step, position, caught, speed, ai):
        self.intervention = intervention
        self.history = history
        self.step = step
        self.position = WorldPoint(intervention, **position)
        self.caught = caught
        self.speed = speed
        self.ai = ai

    def set_position(self, x, y):
        self.position = WorldPoint(self.intervention, x, y)

    def decode(intervention, js, clz):
        return Player(intervention, **js)


class Board(BaseMixin):

    expected_keys = ['boxes', 'tiles', 'height', 'chase_junctions', 'width', 'junctions']

    def __init__(self, intervention, boxes, tiles, height, chase_junctions, width, junctions):
      self.intervention = intervention
      self.width = width
      self.height = height
      self.chase_junctions = chase_junctions
      self.junctions = junctions

      self.boxes = BoxCollection.decode(intervention, boxes,  BoxCollection)
      for box in self.boxes:
        box.top_left._board_init(self)
        box.bottom_right._board_init(self)
  
      self.tiles = TileCollection(intervention, tiles)
  

class TileCollection(BaseMixin):
    # Convenience class to deal with the fact that the tiles blob is
    # an array of arrays, which messes up how our recursive decode calls

    expected_keys = []

    def __init__(self, intervention, tiles):
      self.intervention = intervention
      self.tiles = []
      for i, t in enumerate(tiles):
        row = []
        for j, tag in enumerate(t):
         row.append(Tile(intervention, tag, i, j))
        self.tiles.append(row)

    def __iter__(self):
      return self.tiles.__iter__()

    def __getitem__(self, key):
        return self.tiles[key]

    def __len__(self):
        return len(self.tiles)

    def decode(intervention, tiles, clz):
      return TileCollection(intervention, tiles)

    def encode(self):
      return [[t.encode() for t in row] for row in self.tiles]

    def filter(self, tag):
      lst = []
      for row in self.tiles:
          for tile in row:
              if tile.tag == tag:
                  lst.append(tile)
      return lst

class WorldPoint(BaseMixin):

    expected_keys = ['x', 'y']
  
    def __init__(self, intervention, x=None, y=None):
      assert type(x) is int
      self.x = x
      self.y = y
      self.intervention = intervention

    def to_tile_point(self):
      """Converts this world point to a tile point."""
      tx, ty = self.intervention.toybox.query_state_json('world_to_tile', self.encode())
      return TilePoint(self.intervention, tx, ty)  


class BoxCollection(BaseMixin):

    expected_keys = []

    def __init__(self, intervention, boxes):
        self.boxes = [Box(intervention, **boxdat) for boxdat in boxes]

    def __iter__(self):
        return self.boxes.__iter__()

    def decode(intervention, boxes, clz):
        return BoxCollection(intervention, boxes)

    def encode(self):
        return [b.encode() for b in self.boxes]


class Box(BaseMixin):

    expected_keys = ['triggers_chase', 'top_left', 'bottom_right', 'painted']

    def __init__(self, intervention, triggers_chase, top_left, bottom_right, painted):
        self.intervention = intervention
        self.triggers_chase = triggers_chase
        self.top_left = TilePoint(intervention, **top_left)
        self.bottom_right = TilePoint(intervention, **bottom_right)
        self.painted = painted


class Tile(BaseMixin):
    # Ideally we would have this be an enum, but we'd need to set up 
    # an adaptor class to use multiple inheritence here, and....no.

    Empty = 'Empty'
    Unpainted = 'Unpainted'
    Painted = 'Painted'
    ChaseMarker = 'ChaseMarker'
    tags = [Empty, Unpainted, Painted, ChaseMarker]
    
    expected_keys = []

    def __init__(self, intervention, name, tx, ty):
      assert name in Tile.tags
      self.intervention = intervention
      self.tag = name
      self.tx = tx
      self.ty = ty

    def decode(intervention, rustname, clz):
      return Tile(intervention, rustname)

    def encode(self):
      return self.tag

    def to_tile_point(self):
      return TilePoint(self.intervention, self.tx, self.ty)

    def to_world_point(self): 
      x, y = self.intervention.toybox.query_state_json('tile_to_world', 
        self.to_tile_point().encode())
      return WorldPoint(self.intervention, x, y)


class TilePoint(BaseMixin):

    expected_keys = ['tx', 'ty']

    def __init__(self, intervention, tx, ty):
        self.intervention = intervention
        self.tx = tx
        self.ty = ty
        self.pos = None
        self.board = None

    def __str__(self):
        return 'TilePoint {tx: %d, ty: %d}' % (self.tx, self.ty)

    def _board_init(self, board):
        assert self.tx >= 0 and self.tx < board.width, \
            ('x position %d out of bounds [0, %d)' % (self.tx, board.width))
        assert self.ty >= 0 and self.ty < board.height, \
            ('y position %d out of bounds [0, %d]' % (self.ty, board.height))
        self.pos = self.ty * board.height + self.tx
        self.board = board

    def __setattr__(self, name, value):
      parent = super()
      parent.__setattr__(name, value)

      if 'board' not in self.__dict__ or not self.board:
        # Return early if we have not yet initialized board
        return 

      if name == 'tx':
        parent.__setattr__('pos', self.ty * self.board.height + value)
      
      elif name == 'ty':
        parent.__setattr__('pos', value * self.board.height + self.tx)  

      elif name == 'pos':
        ty = value // self.board.height
        tx = value % self.board.width
        assert pos == (ty * self.board.height + tx)
        parent.__setattr__('ty', ty)
        parent.__setattr__('tx', tx)          

    def is_walkable(self):
      # formerly check_tile_position(self, tdict)
      return self.tag != Tile.empty

    def to_world_point(self):
      return WorldPoint(self.intervention, 
        *self.intervention.toybox.query_state_json('tile_to_world', self.encode()))

class AmidarIntervention(Intervention):

    def __init__(self, tb, game_name='amidar'):
      # check that the simulation in tb matches the game name.
      Intervention.__init__(self, tb, game_name, Amidar)

    def get_random_tile(self, pred=lambda tile: True): 
      """Returns a random tile object, filtered by the input predicate.
      
      Arguments
      ====
      pred:
        boolean function that takes an individual tile as a first argument
        and the rest of the board as the second argument (for making global
        decisions, e.g. only returning the tile if it is some minimum distance
        away from other agents)
      """
      # formerly get_random_tile_id
      while True:
        i = random.randint(0, self.game.board.height - 1)
        j = random.randint(0, self.game.board.width - 1)
        tile = self.game.board.tiles[i][j]
        if pred(tile):
            return tile

    def get_random_track_position(self):
      """Utility function to get a random track tile."""
      # formerly get_random_position
      # grab random tile
      rand_tile = self.get_random_tile(lambda tile, board: tile.tag != 'Empty')  
      # convert random tile to x,y location 
      return rand_tile.to_world()


    def in_regular_mode(self):
      """Predicate that tells us whether the agent is in 'regular' mode (i.e., not jumping, nor chasing enemies.)"""
      return self.game.jump_timer == 0 and self.game.chase_timer == 0

    def jump_mode(self):
      """Predicate indicating whether we are in jump mode, where enemies cannot kill the player."""
      return self.game.jump_timer > 0

    def chase_mode(self):
      """Preidcate indicating whether we are in chase mode, where the player scores extra points for catching enemies."""
      return self.game.chase_timer > 0

    def any_enemy_caught(self, eid):
        return any([self.state['enemies'][i]['caught'] for i in range(len(self.state['enemies']))])


    def set_tile_paint(self, tid, paint=True):
        self.dirty_state = True
        tiles = self.state['board']['tiles']
        assert self.check_is_tile(tid)

        label = "Painted" if paint else "Unpainted"
        self.state['board']['tiles'][tid['ty']][tid['tx']] = label


    def set_mode(self, mode_id='regular', set_time=None): 
        assert mode_id in ['jump', 'chase', 'regular']
        self.dirty_state = True
        if mode_id == 'jump': 
            self.state['jump_timer'] = self.config['jump_time'] if set_time is None else set_time
        elif mode_id == 'chase': 
            self.state['chase_timer'] = self.config['chase_time'] if set_time is None else set_time
        else: #mode_id == 'regular' 
            self.state['jump_timer'] = 0
            self.state['chase_timer'] = 0


    def get_random_dir_for_tile(self, tid):
        assert self.check_tile_position(tid) 
        tile = self.state['board']['tiles'][tid['ty']][tid['tx']]

        assert tile != "Empty"
        selected = False
        dirs = ["Up", "Down", "Left", "Right"]

        d = None
        while not selected: 
            next_tid = {}
            next_tid['tx'] = tid['tx']
            next_tid['ty'] = tid['ty']

            if d is not None: 
                dirs.remove(d)
                if not dirs: 
                    d = None

            d = random.choice(dirs)
            if d == "Up":
                next_tid['ty'] = next_tid['ty'] - 1
            elif d == "Down": 
                next_tid['ty'] = next_tid['ty'] + 1
            elif d == "Left": 
                next_tid['tx'] = next_tid['tx'] - 1
            elif d == "Right":
                next_tid['tx'] = next_tid['tx'] + 1

            if d is not None: 
                selected = not selected and self.check_is_tile(next_tid)

        if d is None:
            raise Exception("No valid direction from this tile:\t\tTile tx:"+str(tid['tx'])+", ty"+str(tid['ty']))
        return d


    


    def add_enemy(self, pos, ai='EnemyLookupAI', **kwargs): 
        self.dirty_state = True
        new_e = {}

        # append kwargs, fill in with defaults
        new_e['history'] = [] if not 'history' in kwargs.keys() else kwargs['history']
        new_e['step'] = None if not 'step' in kwargs.keys() else kwargs['step']
        new_e['caught'] = False if not 'caught' in kwargs.keys() else kwargs['caught']
        new_e['speed'] = 8 if not 'speed' in kwargs.keys() else kwargs['speed']

        assert Intervention.check_position(self, pos, ['x', 'y'])
        new_e['position'] = pos
        
        # we can't use self.set_enemy_protocol(...) here because Rust will rightly complain that the enemy added to 
        # the list of enemies does not contain a movement protocol

        # instead, we add the default protocol JSON to the new enemy
        eid = self.num_enemies()
        new_e['ai'] = {}
        new_e['ai'][ai] = self.get_default_protocol(ai, eid, pos, **kwargs)

        # then append the complete enemy to the list
        self.state['enemies'].append(new_e)





### difficult interventions ###
    # random start state?
    # enemy perimeter direction 
    # tie random selections to Toybox environment seed?


if __name__ == "__main__":
    import argparse 

    parser = argparse.ArgumentParser(description='test Amidar interventions')
    parser.add_argument('--partial_config', type=str, default="null")
    parser.add_argument('--save_json', type=bool, default=False)
    parser.add_argument('--save_tile_images', type=bool, default=False)

    pre_img_path = "pre_img.jpg"
    post_img_path = "post_img.jpg"

    args = parser.parse_args()

    with Toybox('amidar') as tb:
        state = tb.to_state_json()
        config = tb.config_to_json()

        if args.save_json:
            # save a sample starting state and config
            with open('toybox/toybox/interventions/defaults/amidar_state_default.json', 'w') as outfile:
                json.dump(state, outfile)

            with open('toybox/toybox/interventions/defaults/amidar_config_default.json', 'w') as outfile:
                json.dump(config, outfile)

         # num tiles unpainted
        with AmidarIntervention(tb) as intervention:
            tiles_unpainted = intervention.num_tiles_unpainted()
        #assert tiles_unpainted == 356

        if args.save_tile_images: 
            for ty in range(len(state['board']['tiles'])):
                for tx in range(len(state['board']['tiles'][ty])):
                    tile_pos = {'tx':tx, 'ty':ty}

                    with AmidarIntervention(tb) as intervention:
                        is_tile = intervention.check_is_tile(tile_pos)

                    if is_tile:
                        with AmidarIntervention(tb) as intervention:
                                intervention.set_tile_paint(tile_pos)

                        fname = 'tile_tx_'+str(tx)+'_ty_'+str(ty)+'.jpg'
                        tb.save_frame_image(fname, grayscale=False)

                        with AmidarIntervention(tb) as intervention: 
                            intervention.set_tile_paint(tile_pos, False)

       

        # test painting
        tile_pos = {'tx':0, 'ty':0}
        with AmidarIntervention(tb) as intervention:
            intervention.set_tile_paint(tile_pos)
        with AmidarIntervention(tb) as intervention:
            assert intervention.state['board']['tiles'][tile_pos['ty']][tile_pos['tx']] == "Painted"


        # test unpainting
        tile_pos = {'tx':0, 'ty':0}
        with AmidarIntervention(tb) as intervention:
            intervention.set_tile_paint(tile_pos, False)
        with AmidarIntervention(tb) as intervention:
            # note that this tile was originally a ChaseMarker but that case is not handled 
            # by these intervention functions
            assert intervention.state['board']['tiles'][tile_pos['ty']][tile_pos['tx']] == "Unpainted"


        # get number of enemies
        with AmidarIntervention(tb) as intervention: 
            n_enemies = intervention.num_enemies()
        assert n_enemies == 5


        # remove enemy
        with AmidarIntervention(tb) as intervention: 
            pos = intervention.state['enemies'][4]['position']
            intervention.remove_enemy(4)
        # get number of enemies
        with AmidarIntervention(tb) as intervention: 
            n_enemies = intervention.num_enemies()
        # check one has been removed
        assert n_enemies == 4


        # add enemy with 'EnemyLookupAI' protocol
        with AmidarIntervention(tb) as intervention: 
            #pos = get_random_position()
            intervention.add_enemy(pos, speed=8)
        # get number of enemies
        with AmidarIntervention(tb) as intervention: 
            n_enemies = intervention.num_enemies()
        # check one has been added back
        assert n_enemies == 5

        # change to 'EnemyPerimeterAI' protocol
        change_eid = n_enemies - 1
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyPerimeterAI')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyPerimeterAI'].keys()
        assert 'EnemyPerimeterAI' in ai_keys and len(ai_keys) == 1 
        print('EnemyPerimeterAI', ai_args)
        #assert len(ai_args) == 5

        # change to 'EnemyAmidarMvmt' protocol
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyAmidarMvmt')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyAmidarMvmt'].keys()
        assert 'EnemyAmidarMvmt' in ai_keys and len(ai_keys) == 1 
        print('EnemyAmidarMvmt', ai_args)
        assert len(ai_args) == 5

        # change to 'EnemyTargetPlayer' protocol
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyTargetPlayer')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyTargetPlayer'].keys()
        assert 'EnemyTargetPlayer' in ai_keys and len(ai_keys) == 1 
        print('EnemyTargetPlayer', ai_args)


        # change to 'EnemyRandomAI' protocol
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyRandomMvmt')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyRandomMvmt'].keys()
        assert 'EnemyRandomMvmt' in ai_keys and len(ai_keys) == 1 
        print('EnemyRandomMvmt', ai_args)



        # check number of jumps
        with AmidarIntervention(tb) as intervention: 
            n_jumps = intervention.jumps_remaining()
        assert n_jumps == 4

        # set number of jumps
        with AmidarIntervention(tb) as intervention:
            intervention.set_n_jumps(5)
        with AmidarIntervention(tb) as intervention:
            n_jumps = intervention.jumps_remaining()
        assert n_jumps == 5


        # check number of lives
        # set number of lives

        # check jump mode
        with AmidarIntervention(tb) as intervention:
            intervention.set_mode('jump')
        with AmidarIntervention(tb) as intervention:
            jump_timer = intervention.state['jump_timer']
        assert jump_timer > 0



        #tb.save_frame_image(pre_img_path)
        #with AmidarIntervention(tb) as intervention: 
        #    pass
        #tb.save_frame_image(post_img_path, grayscale=False)


        # player_tile
        # regular_mode
        # jump_mode
        # chase_mode
        # enemy_tiles
        # enemy caught
        # any_enemy_caught
        # set box
        # check chase condition
        # chase react
        # set player tile
        # set enemy tile
        # set enemy tiles
        # set mode
        # get enemy protocol 
        # get enemy protocols 
        # set_enemy_protocol
        # get_default_protocol (one for each of 5)
        # get random tile ID
        # get random position 
        # get random direction for tile
        # set enemy protocols 
