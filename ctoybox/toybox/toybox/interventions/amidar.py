from toybox.interventions.base import *

import json
import random
from collections import namedtuple
"""An API for interventions on Amidar."""

# Someday all of these objects will be auto-generated by the Rust. 
# For now, manually specify them.

class Amidar(Game):

  expected_keys = Game.expected_keys + ['enemies', 'jumps', 'jump_timer', 'chase_timer', 'board']
  
  def __init__(self, intervention, 
    score=None, player=None, lives=None, rand=None, level=None,
    enemies=None, jumps=None, jump_timer=None, chase_timer=None, board=None):
    print('Amidar init')
    super().__init__(intervention, score, player, lives, rand, level)
    self.enemies = EnemyCollection.decode(intervention, enemies, EnemyCollection)
    self.jumps = jumps
    self.jump_timer = jump_timer
    self.chase_timer = chase_timer
    self.board = Board.decode(intervention, board, Board)

  def __setattr__(self, name, value):
    calling_fn = inspect.stack()[1].function
    if name == 'enemies' and calling_fn != '__init__':
        coll = EnemyCollection(self.intervention, value, directset=True)
        super().__setattr__(name, coll)
        self.intervention.dirty_state = True
        # Enemies are part of the Amidar config
        # This should be done in a more principled way, but right now I'm just trying to debug.
        # print(self.intervention.config); exit(0)
        # self.intervention.config['enemies'] = coll.encode()
        # self.intervention.dirty_config = True
    else:
        super().__setattr__(name, value)


class EnemyCollection(BaseMixin):

    expected_keys = []

    def __init__(self, intervention, enemies, directset=False):
        self.intervention = intervention
        self.enemies = enemies if directset else [Enemy.decode(intervention, e, Enemy) for e in enemies]
        
    def __iter__(self):
        return self.enemies.__iter__()

    def __getitem__(self, key):
        return self.enemies.__getitem__(key)

    def __len__(self):
        return self.enemies.__len__()

    def decode(intervention, enemies, clz):
        return EnemyCollection(intervention, enemies)

    def encode(self):
        return [e.encode() for e in self.enemies]


class Enemy(BaseMixin):

    EnemyLookupAI     ='EnemyLookupAI'
    EnemyPerimeterAI  = 'EnemyPerimeterAI' 
    EnemyAmidarMvmt   = 'EnemyAmidarMvmt' 
    EnemyTargetPlayer = 'EnemyTargetPlayer'
    EnemyRandomMvmt   = 'EnemyRandomMvmt'

    mvmt_protocols = [
        EnemyLookupAI, 
        EnemyPerimeterAI, 
        EnemyAmidarMvmt, 
        EnemyTargetPlayer, 
        EnemyRandomMvmt]

    expected_keys = ['history', 'step', 'position', 'caught', 'speed', 'ai']

    def __init__(self, intervention, history, step, position, caught, speed, ai):
      self.intervention = intervention
      self.history = history
      self.step = step
      self.position = WorldPoint(intervention, **position)
      self.caught = caught
      self.speed = speed
      assert len(ai.keys()) == 1  
      self.ai_name = list(ai.keys())[0]
      self.ai_kwds = ai[self.ai_name]
      assert self.ai_name in Enemy.mvmt_protocols

    def __setattr__(self, name, value):
      calling_fn = inspect.stack()[1].function
      if name.startswith('ai') and not (calling_fn == 'set_protocol' or calling_fn == '__init__'):
          raise AttributeError('Cannot manually set ai, ai_kwds, or ai_name. Use set_protocol instead.')
      super().__setattr__(name, value)
        
    def encode(self):
      js = super().encode()
      obj = {}
      for name, value in self.ai_kwds.items():
          obj[name] = value.encode() if isinstance(value, BaseMixin) else value
      js['ai'] = {self.ai_name : obj}
      return js

    def get_ai_arg(self, argname):
      """Returns the value of the input keyword. 
         
         All enemy movement protocols have the form:

         { <ai_name> : <keywords> }

         <ai_name> is one of the values listed in Enemy.mvmt_protocols.

         <keywords> is a map of enum elements needed for the rust. See the documentation for set_protocol for more information.
      """
      return self.ai_kwds[argname]

    def get_ai_kwds(self):
      return self.ai_kwds.keys()

    def set_protocol(self, protocol, **kwargs):
      """Sets the enemy movement protocol. Each instance in the   rust has a different set of parameters:
  
      EnemyLookupAI
        next: u32
        default_route_index: u32
          
      EnemyPerimeterAI 
        start: TilePoint
  
      EnemyAmidarMvmt 
        vert: Direction
        horiz: Direction
        start_vert: Direction
        start_horiz: Direction
        start: TilePoint 
  
      EnemyRandomMvmt
        start: TilePoint
        start_dir: Direction
        dir: Direction
  
      EnemyTargetPlayer 
        start: TilePoint
        start_dir: Direction
        vision_distance: i32
        dir: Direction
        player_seen: Option<TilePoint>"""
      assert protocol in Enemy.mvmt_protocols
      def assert_keys(k, t): 
          assert k in kwargs, 'Missing argument %s for protocol %s' % (k, protocol)
          # 
        #   v = kwargs[k]
        #   assert isinstance(v, t), 'Argument %s must be of type %s; is %s' % (k, t, type(v))
      if protocol == Enemy.EnemyLookupAI:
          assert_keys('next', int)
          assert_keys('default_route_index', int)
      elif protocol == Enemy.EnemyPerimeterAI:
          assert_keys('start', TilePoint)
      elif protocol == Enemy.EnemyAmidarMvmt:
          assert_keys('vert', Direction)
          assert_keys('horiz', Direction)
          assert_keys('start_vert', Direction)
          assert_keys('start_horiz', Direction)
          assert_keys('start', TilePoint)
      elif protocol == Enemy.EnemyTargetPlayer:
          assert_keys('start', TilePoint)
          assert_keys('start_dir', Direction)
          assert_keys('vision_distance', int)
          assert_keys('dir', Direction)
          try: 
            assert_keys('player_seen', None)
          except:
            assert_keys('player_seen', TilePoint)
      else: assert False
      self.ai_name = protocol
      self.ai_kwds = kwargs
  

class Player(BaseMixin):

    expected_keys = ['history', 'step', 'position', 'caught', 'speed', 'ai']

    def __init__(self, intervention, history, step, position, caught, speed, ai):
        self.intervention = intervention
        self.history = history
        self.step = step
        self.position = WorldPoint(intervention, **position)
        self.caught = caught
        self.speed = speed
        self.ai = ai

    def set_position(self, x, y):
        self.position = WorldPoint(self.intervention, x, y)


class Board(BaseMixin):

    expected_keys = ['boxes', 'tiles', 'height', 'chase_junctions', 'width', 'junctions']

    def __init__(self, intervention, boxes, tiles, height, chase_junctions, width, junctions):
      self.intervention = intervention
      self.width = width
      self.height = height
      self.chase_junctions = chase_junctions
      self.junctions = junctions

      self.boxes = BoxCollection.decode(intervention, boxes,  BoxCollection)
      for box in self.boxes:
        box.top_left._board_init(self)
        box.bottom_right._board_init(self)
  
      self.tiles = TileCollection(intervention, tiles)
  

class TileCollection(BaseMixin):
    # Convenience class to deal with the fact that the tiles blob is
    # an array of arrays, which messes up how our recursive decode calls

    expected_keys = []

    def __init__(self, intervention, tiles):
        self.tiles = [[Tile(intervention, tile) for tile in row] for row in tiles]

    def __iter__(self):
        return self.tiles.__iter__()

    def decode(intervention, tiles, clz):
        return TileCollection(intervention, tiles, TileCollection)

    def encode(self):
        return [[t.encode() for t in row] for row in self.tiles]


class WorldPoint(BaseMixin):

    expected_keys = ['x', 'y']
  
    def __init__(self, intervention, x=None, y=None):
        assert type(x) is int
        self.x = x
        self.y = y
        self.intervention = intervention        


class BoxCollection(BaseMixin):

    expected_keys = []

    def __init__(self, intervention, boxes):
        self.boxes = [Box(intervention, **boxdat) for boxdat in boxes]

    def __iter__(self):
        return self.boxes.__iter__()

    def decode(intervention, boxes, clz):
        return BoxCollection(intervention, boxes)

    def encode(self):
        return [b.encode() for b in self.boxes]


class Box(BaseMixin):

    expected_keys = ['triggers_chase', 'top_left', 'bottom_right', 'painted']

    def __init__(self, intervention, triggers_chase, top_left, bottom_right, painted):
        self.intervention = intervention
        self.triggers_chase = triggers_chase
        self.top_left = TilePoint(intervention, **top_left)
        self.bottom_right = TilePoint(intervention, **bottom_right)
        self.painted = painted


class Tile(BaseMixin):
    # Ideally we would have this be an enum, but we'd need to set up 
    # an adaptor class to use multiple inheritence here, and....no.

    Empty = 'Empty'
    Unpainted = 'Unpainted'
    Painted = 'Painted'
    ChaseMarker = 'ChaseMarker'
    tags = [Empty, Unpainted, Painted, ChaseMarker]
    
    expected_keys = []

    def __init__(self, intervention, name):
        assert name in Tile.tags
        self.intervention = intervention
        self.tag = name

    def decode(intervention, rustname, clz):
        return Tile(intervention, rustname)

    def encode(self):
        return self.tag


class TilePoint(BaseMixin):

    expected_keys = ['tx', 'ty']

    def __init__(self, intervention, tx, ty):
        self.intervention = intervention
        self.tx = tx
        self.ty = ty
        self.pos = None
        self.board = None

    def _board_init(self, board):
        assert self.tx >= 0 and self.tx < board.width, \
            ('x position %d out of bounds [0, %d)' % (self.tx, board.width))
        assert self.ty >= 0 and self.ty < board.height, \
            ('y position %d out of bounds [0, %d]' % (self.ty, board.height))
        self.pos = self.ty * board.height + self.tx
        self.board = board

    def __setattr__(self, name, value):
      parent = super()
      parent.__setattr__(name, value)

      if 'board' not in self.__dict__ or not self.board:
        # Return early if we have not yet initialized board
        return 

      if name == 'tx':
        parent.__setattr__('pos', self.ty * self.board.height + value)
      
      elif name == 'ty':
        parent.__setattr__('pos', value * self.board.height + self.tx)  

      elif name == 'pos':
        ty = value // self.board.height
        tx = value % self.board.width
        assert pos == (ty * self.board.height + tx)
        parent.__setattr__('ty', ty)
        parent.__setattr__('tx', tx)          

    def is_walkable(self):
        # formerly check_tile_position(self, tdict)
        return self.tag != Tile.empty


class AmidarIntervention(Intervention):

    def __init__(self, tb, game_name='amidar'):
        # check that the simulation in tb matches the game name.
        Intervention.__init__(self, tb, game_name, Amidar)

    def get_random_tile_id(self): 
        tile = {}

        ty = random.choice(range(len(self.state['board']['tiles'])))
        which_tiles = [i for i in range(len(self.state['board']['tiles'][ty])) if self.state['board']['tiles'][ty][i] != "Empty"]
        tx = random.choice(which_tiles)

        tile['tx'] = tx
        tile['ty'] = ty

        return tile


    def get_random_position(self):
        # grab random tile
        rand_tile = self.get_random_tile_id()
    
        # convert random tile to x,y location 
        x, y = self.tile_to_world(rand_tile['tx'], rand_tile['ty'])
        return WorldPoint(x, y)

    def world_to_tile(self, x, y): 
        worldpoint = WorldPoint(self, x, y)
        (tx, ty) = self.toybox.query_state_json("world_to_tile", worldpoint.encode())

        tile = {}
        tile['tx'] = tx
        tile['ty'] = ty
        return tile


    def tile_to_world(self, tx, ty): 
        tilepoint = {'tx': tx, 'ty': ty}
        (x, y) = self.toybox.query_state_json("tile_to_world", tilepoint)
        return WorldPoint(x, y)


    def num_tiles_unpainted(self):
        total_unpainted = 0
        for i in range(len(self.state['board']['tiles'])): 
            total_unpainted += sum([tile != "Painted" and tile != "Empty" for tile in self.state['board']['tiles'][i]])

        return total_unpainted


    def num_tiles_painted(self):
        return sum([sum([int(tile == 'Painted') for tile in row]) for row in self.state['board']['tiles']])

        
    def player_tile(self):
        return self.state['player']['position']

    def get_enemies(self):
        return self.state['enemies']
    
    def get_enemy_ids(self):
        print('WARNING: need actual ids in the rust')
        return range(self.num_enemies())

    def num_enemies(self):
        return len(self.state['enemies'])

    def get_level(self):
        return self.config['level']

    # def get_lives(self):
    #     return self.state['lives']

    def jumps_remaining(self):
        return self.state['jumps']

    def regular_mode(self):
        return self.state['jump_timer'] == 0 and self.state['chase_timer'] == 0

    def jump_mode(self):
        return self.state['jump_timer'] > 0

    def chase_mode(self):
        return self.state['chase_timer'] > 0

    def enemy_tiles(self):
        return [self.state['enemies'][i]['position'] for i in range(len(self.state['enemies']))]

    def enemy_caught(self, eid):
        return self.state['enemies'][eid]['caught']

    def any_enemy_caught(self, eid):
        return any([self.state['enemies'][i]['caught'] for i in range(len(self.state['enemies']))])


    def set_tile_paint(self, tid, paint=True):
        self.dirty_state = True
        tiles = self.state['board']['tiles']
        assert self.check_is_tile(tid)

        label = "Painted" if paint else "Unpainted"
        self.state['board']['tiles'][tid['ty']][tid['tx']] = label


    # def set_box(self, bid, paint=True, include_tiles=True, allow_chase=True):
    #     self.dirty_state = True
    #     box = self.state['board']['boxes'][bid]
    #     box['painted'] = paint

    #     if allow_chase: 
    #         # if we allow the intervention to trigger chasing, 
    #         # we only want to do so if it was not already triggered 
    #         allow_chase = allow_chase and not self.check_chase_condition()

    #     if include_tiles: 
    #         tx_left = box['top_left']['tx']
    #         ty_left = box['top_left']['ty']
    #         tx_right = box['bottom_right']['tx']
    #         ty_right = box['bottom_right']['ty']

    #         for i in range(tx_left, tx_right+1): 
    #             for j in range(ty_left, ty_right+1):
    #                 if self.state['board']['tiles'][i][j] != "Empty": 
    #                     self.state['board']['tiles'][i][j] = "Painted"

    #     if allow_chase: 
    #         self.chase_react()


    # def check_chase_condition(self): 
    #     chase = False
    #     continue_check = True

    #     for box in self.state['board']['boxes']: 
    #         if box['triggers_chase']: 
    #             tx_left = box['top_left']['tx']
    #             ty_left = box['top_left']['ty']
    #             tx_right = box['bottom_right']['tx']
    #             ty_right = box['bottom_right']['ty']

    #             all_painted = True
    #             for i in range(tx_left, tx_right+1): 
    #                 for j in range(ty_left, ty_right+1):
    #                     if self.state['board']['tiles'][i][j] != "Empty": 
    #                         all_painted &= self.state['board']['tiles'][i][j] == "Painted"
    #                     if not all_painted: 
    #                         continue_check = False
    #                         break
    #                 if not continue_check:
    #                     break

    #         if not continue_check: 
    #             break

    #     return all_painted


    # def chase_react(self): 
    #     self.dirty_state = True
    #     if self.check_chase_condition(): 
    #         self.set_mode('chase')


    # def set_player_tile(self, pos):
    #     self.dirty_state = True
    #     # check the input formatting
    #     assert Intervention.check_position(self, pos, ['x','y'])

    #     # get tile for new position
    #     # check that this is a walkable, valid tile
    #     tile = self.world_to_tile(pos)
    #     assert self.check_tile_position(tile)

    #     # now set the position
    #     self.state['player']['position']['x'] = pos['x']
    #     self.state['player']['position']['y'] = pos['y']


    # def set_enemy_tile(self, eid, pos):
    #     self.dirty_state = True
    #     assert Intervention.check_position(self, pos, ['x', 'y'])

    #     self.state['enemies'][eid]['position']['x'] = pos['x']
    #     self.state['enemies'][eid]['position']['y'] = pos['y']


    # def set_enemy_tiles(self, eids, pos_list):
    #     self.dirty_state = True
    #     assert len(eids) == len(pos_list)

    #     for i, eid in enumerate(eids): 
    #         set_enemy_tile(eid, pos_list[i])


    def set_mode(self, mode_id='regular', set_time=None): 
        assert mode_id in ['jump', 'chase', 'regular']
        self.dirty_state = True
        if mode_id == 'jump': 
            self.state['jump_timer'] = self.config['jump_time'] if set_time is None else set_time
        elif mode_id == 'chase': 
            self.state['chase_timer'] = self.config['chase_time'] if set_time is None else set_time
        else: #mode_id == 'regular' 
            self.state['jump_timer'] = 0
            self.state['chase_timer'] = 0


    # def get_enemy_protocol(self, eid): 
    #     return self.state['enemies'][eid]['ai']


    # def get_enemy_protocols(self, eids): 
    #     return [self.state['enemies'][eid]['ai'] for eid in eids]





    def get_random_dir_for_tile(self, tid):
        assert self.check_tile_position(tid) 
        tile = self.state['board']['tiles'][tid['ty']][tid['tx']]

        assert tile != "Empty"
        selected = False
        dirs = ["Up", "Down", "Left", "Right"]

        d = None
        while not selected: 
            next_tid = {}
            next_tid['tx'] = tid['tx']
            next_tid['ty'] = tid['ty']

            if d is not None: 
                dirs.remove(d)
                if not dirs: 
                    d = None

            d = random.choice(dirs)
            if d == "Up":
                next_tid['ty'] = next_tid['ty'] - 1
            elif d == "Down": 
                next_tid['ty'] = next_tid['ty'] + 1
            elif d == "Left": 
                next_tid['tx'] = next_tid['tx'] - 1
            elif d == "Right":
                next_tid['tx'] = next_tid['tx'] + 1

            if d is not None: 
                selected = not selected and self.check_is_tile(next_tid)

        if d is None:
            raise Exception("No valid direction from this tile:\t\tTile tx:"+str(tid['tx'])+", ty"+str(tid['ty']))
        return d


    
    def set_enemy_protocols(self, eids, protocols=None):
        self.dirty_state = True
        if protocols is None: 
            protocols = ['EnemyAmidarMvmt']*len(eids) 
        assert len(eids) == len(protocols)

        for i, eid in enumerate(eids):
            self.set_enemy_protocol[eid, protocols[i]] 


    def add_enemy(self, pos, ai='EnemyLookupAI', **kwargs): 
        self.dirty_state = True
        new_e = {}

        # append kwargs, fill in with defaults
        new_e['history'] = [] if not 'history' in kwargs.keys() else kwargs['history']
        new_e['step'] = None if not 'step' in kwargs.keys() else kwargs['step']
        new_e['caught'] = False if not 'caught' in kwargs.keys() else kwargs['caught']
        new_e['speed'] = 8 if not 'speed' in kwargs.keys() else kwargs['speed']

        assert Intervention.check_position(self, pos, ['x', 'y'])
        new_e['position'] = pos
        
        # we can't use self.set_enemy_protocol(...) here because Rust will rightly complain that the enemy added to 
        # the list of enemies does not contain a movement protocol

        # instead, we add the default protocol JSON to the new enemy
        eid = self.num_enemies()
        new_e['ai'] = {}
        new_e['ai'][ai] = self.get_default_protocol(ai, eid, pos, **kwargs)

        # then append the complete enemy to the list
        self.state['enemies'].append(new_e)


    def remove_enemy(self, eid):
        self.dirty_state = True
        assert eid < self.num_enemies() and eid >=0 
        enemies = [self.state['enemies'][i] for i in range(len(self.state['enemies'])) if i != eid]
        self.state['enemies'] = enemies


    def set_n_jumps(self, n):  
        self.dirty_state = True      
        assert n >= 0
        self.state['jumps'] = n


    def set_n_lives(self, n):
        self.dirty_state = True
        assert n > 0 
        self.state['lives'] = n

    # set enemy protocol 
    # get, set score
        # consider logic for score calculation

### difficult interventions ###
    # random start state?
    # enemy perimeter direction 
    # tie random selections to Toybox environment seed?


if __name__ == "__main__":
    import argparse 

    parser = argparse.ArgumentParser(description='test Amidar interventions')
    parser.add_argument('--partial_config', type=str, default="null")
    parser.add_argument('--save_json', type=bool, default=False)
    parser.add_argument('--save_tile_images', type=bool, default=False)

    pre_img_path = "pre_img.jpg"
    post_img_path = "post_img.jpg"

    args = parser.parse_args()

    with Toybox('amidar') as tb:
        state = tb.to_state_json()
        config = tb.config_to_json()

        if args.save_json:
            # save a sample starting state and config
            with open('toybox/toybox/interventions/defaults/amidar_state_default.json', 'w') as outfile:
                json.dump(state, outfile)

            with open('toybox/toybox/interventions/defaults/amidar_config_default.json', 'w') as outfile:
                json.dump(config, outfile)

         # num tiles unpainted
        with AmidarIntervention(tb) as intervention:
            tiles_unpainted = intervention.num_tiles_unpainted()
        #assert tiles_unpainted == 356

        if args.save_tile_images: 
            for ty in range(len(state['board']['tiles'])):
                for tx in range(len(state['board']['tiles'][ty])):
                    tile_pos = {'tx':tx, 'ty':ty}

                    with AmidarIntervention(tb) as intervention:
                        is_tile = intervention.check_is_tile(tile_pos)

                    if is_tile:
                        with AmidarIntervention(tb) as intervention:
                                intervention.set_tile_paint(tile_pos)

                        fname = 'tile_tx_'+str(tx)+'_ty_'+str(ty)+'.jpg'
                        tb.save_frame_image(fname, grayscale=False)

                        with AmidarIntervention(tb) as intervention: 
                            intervention.set_tile_paint(tile_pos, False)

       

        # test painting
        tile_pos = {'tx':0, 'ty':0}
        with AmidarIntervention(tb) as intervention:
            intervention.set_tile_paint(tile_pos)
        with AmidarIntervention(tb) as intervention:
            assert intervention.state['board']['tiles'][tile_pos['ty']][tile_pos['tx']] == "Painted"


        # test unpainting
        tile_pos = {'tx':0, 'ty':0}
        with AmidarIntervention(tb) as intervention:
            intervention.set_tile_paint(tile_pos, False)
        with AmidarIntervention(tb) as intervention:
            # note that this tile was originally a ChaseMarker but that case is not handled 
            # by these intervention functions
            assert intervention.state['board']['tiles'][tile_pos['ty']][tile_pos['tx']] == "Unpainted"


        # get number of enemies
        with AmidarIntervention(tb) as intervention: 
            n_enemies = intervention.num_enemies()
        assert n_enemies == 5


        # remove enemy
        with AmidarIntervention(tb) as intervention: 
            pos = intervention.state['enemies'][4]['position']
            intervention.remove_enemy(4)
        # get number of enemies
        with AmidarIntervention(tb) as intervention: 
            n_enemies = intervention.num_enemies()
        # check one has been removed
        assert n_enemies == 4


        # add enemy with 'EnemyLookupAI' protocol
        with AmidarIntervention(tb) as intervention: 
            #pos = get_random_position()
            intervention.add_enemy(pos, speed=8)
        # get number of enemies
        with AmidarIntervention(tb) as intervention: 
            n_enemies = intervention.num_enemies()
        # check one has been added back
        assert n_enemies == 5

        # change to 'EnemyPerimeterAI' protocol
        change_eid = n_enemies - 1
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyPerimeterAI')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyPerimeterAI'].keys()
        assert 'EnemyPerimeterAI' in ai_keys and len(ai_keys) == 1 
        print('EnemyPerimeterAI', ai_args)
        #assert len(ai_args) == 5

        # change to 'EnemyAmidarMvmt' protocol
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyAmidarMvmt')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyAmidarMvmt'].keys()
        assert 'EnemyAmidarMvmt' in ai_keys and len(ai_keys) == 1 
        print('EnemyAmidarMvmt', ai_args)
        assert len(ai_args) == 5

        # change to 'EnemyTargetPlayer' protocol
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyTargetPlayer')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyTargetPlayer'].keys()
        assert 'EnemyTargetPlayer' in ai_keys and len(ai_keys) == 1 
        print('EnemyTargetPlayer', ai_args)


        # change to 'EnemyRandomAI' protocol
        with AmidarIntervention(tb) as intervention: 
            intervention.set_enemy_protocol(change_eid, 'EnemyRandomMvmt')
        with AmidarIntervention(tb) as intervention: 
            ai_keys = intervention.state['enemies'][change_eid]['ai'].keys()
            ai_args = intervention.state['enemies'][change_eid]['ai']['EnemyRandomMvmt'].keys()
        assert 'EnemyRandomMvmt' in ai_keys and len(ai_keys) == 1 
        print('EnemyRandomMvmt', ai_args)



        # check number of jumps
        with AmidarIntervention(tb) as intervention: 
            n_jumps = intervention.jumps_remaining()
        assert n_jumps == 4

        # set number of jumps
        with AmidarIntervention(tb) as intervention:
            intervention.set_n_jumps(5)
        with AmidarIntervention(tb) as intervention:
            n_jumps = intervention.jumps_remaining()
        assert n_jumps == 5


        # check number of lives
        # set number of lives

        # check jump mode
        with AmidarIntervention(tb) as intervention:
            intervention.set_mode('jump')
        with AmidarIntervention(tb) as intervention:
            jump_timer = intervention.state['jump_timer']
        assert jump_timer > 0



        #tb.save_frame_image(pre_img_path)
        #with AmidarIntervention(tb) as intervention: 
        #    pass
        #tb.save_frame_image(post_img_path, grayscale=False)


        # player_tile
        # regular_mode
        # jump_mode
        # chase_mode
        # enemy_tiles
        # enemy caught
        # any_enemy_caught
        # set box
        # check chase condition
        # chase react
        # set player tile
        # set enemy tile
        # set enemy tiles
        # set mode
        # get enemy protocol 
        # get enemy protocols 
        # set_enemy_protocol
        # get_default_protocol (one for each of 5)
        # get random tile ID
        # get random position 
        # get random direction for tile
        # set enemy protocols 
